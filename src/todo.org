* TODO rebooting is dying
** DONE hotload ui layer
CLOSED: [2019-06-29 Sat 23:15]
** DONE hotload interface
CLOSED: [2019-06-29 Sat 23:15]
** DONE hotload class
CLOSED: [2019-06-29 Sat 23:15]
** DONE data:edit
CLOSED: [2019-07-04 Thu 11:08]
** DONE Hook.add()
CLOSED: [2019-07-04 Thu 11:08]
* TODO map/outer map handling (base)
when is it necessary to iterate all maps?
- when updating the world map with mapupdate=1 (the map exists or is being reset via diastrophism).
- when getting a list of locations to return to. it checks if the area is visited, if it can be returned to, and the deepest level. this means that when traveling somewhere, it is necessary to know where to set the area's deepest level.

places in area data.
500 is the max number of areas.
0: empty
1-100:   global uniquely instanced maps. if a map's id is "vernis", then it is the only vernis.
101-104: base id for generated buildings. not actually used as a map id; instead the area id is referred to.
300-450: created user buildings. more than one building with the same map id can exist here.
450-500: generated nefias.
300-500: non-unique maps (buildings/nefias)

from this there are a few distinct types of maps:
- unique maps. only one of these maps can ever be instantiated. if an area is ID '1', then it will always refer to the single copy of map ID '1' and never anything else.
- buildings, with a concrete map ID but differing area ID. more than one building can exist with the same map ID.
- dungeons, which are replaced after being conquered and have no real map ID. each is unique.

in the end, we have to be able to:
- distinguish maps from areas.
- get the area a map is part of. maps will always have an area, there will always be exactly one area loaded in the global data, and there will always be exactly one map in that area that is the current map.
- get the parent map of the maps in this area where the map entrance is located. from there you could get the parent map's enclosing area also.
- relocate generated areas that overlap with any other areas on the same map. (or not, by asserting everything is properly located to begin with)
- iterate all known areas in the current savefile regardless of where they are. used for return magic.
- remove the limitation of being able to have only one copy of each unique map. maps are referred to by a generated uid instead.
- travel to any arbitrary map without knowing its area beforehand and not breaking anything.
  + does it make sense for a map to not belong to an area? if so, what happens when traveling to it?
- get the "one true copy" of a map if requested. this has to be based on uid instead of prototype to support multiple instances. basically, "find the first uid with this prototype id, and if more than one exists then warn loudly". unsurprisingly this should be able to be set programmatically. this also gets used when connecting maps for quests.
  + it probably makes sense to set the ID of a map to blank if it isn't unique. this would be the case for random nefias, since they all share the same ID but can have multiple copies. instead we could rely on a uid for determining which map is the true copy.
- create multiple instances of any map without issues. this becomes tricky when handling quest destinations. if two vernises are created, the game has to decide which is the quest target. or maybe not, and instead warning the player of this circumstance.
  + it probably won't be possible for the player to just spawn vernis if playing normally. it would be better to just refer to the uid of each and add a flag indicating this is a quest destination, or by looking at the map's types for "base.quest_target".
- spawn new areas trivially.
- load areas containing maps into memory and be able to hotswap them.
- load individual maps and be able to hotswap them.
- obtain the deepest level in an area the player has visited.
- support pathological features like the void. the conquering logic is shared between nefias and the void, but conquering a void boss doesn't set the conquered flag on the area. having "base.nefia" and "base.void" map types would help, and having the map emit "on_conquer" to handle specific logic.
- filter areas by ones that are "nefia" to do things like clearing them out.
  + have to be extremely careful here. "random_dungeon" is a concrete map ID for all nefias, but maps like lesimas have "dungeon" as the "map type". so lesimas technically counts as a nefia in the is_nefia() call. basically, this should be replaced with has_type("base.dungeonlike"). for clearing random dungeons, what we want is not "is_dungeonlike" but "is_nefia", or checking for "base.nefia" in the class.
- connect quest destinations by iterating all the areas on a specific world map.
- nest maps of different areas arbitrarily. you could support dungeon branching this way.

when adding stairs, all that is there is the map UID. if the map pointed to is in the same area, then just hotswap. else, read the list of maps in the area from disk and travel there.

** lookup
_how do you convert a map ID to an area ID?_
1. keep an `_area_id` field on the map. but changing it breaks various things, since the enclosing area will also reference it. though, we do this already with `_location`.
2. keep a global mapping somewhere. globals are bad, but it solves the problem so long as it is kept in sync across every known area. this lets us keep one source of truth that can be managed entirely internally.
** area
areas solve these problems:
- player wants to travel to the deepest level of lesimas they have visited so far.
- determining if a nefia, which is a collection of individual maps, has been conquered.

to do this we have to know which maps are related to each other, like which ones are on each dungeon level. so at bare minimum there must be a group of maps to iterate through. that group has to be stored somewhere.

actually, half the fields on areas are just copied to each individual submap.
- current dungeon level
- atlas/tileset
- map type
- turn cost
- refresh type/generated every time
- designated spawns
- indoors

and some of them are copied from mdata but are completely unreferenced in the mdata itself (it always uses the parent area to check the value):
- danger level
- deepest level
- quest town id
+these can simply be copied to each map without requiring all maps in the area share the same value.+
no, because if there is code changing the danger level, then all child maps have to have the same value copied too. you have to be able to do Area.set_danger_level(area) for each map in the area, and to do that you have to know which maps to update, as in which maps belong to the area.

the final question is: can these features be replicated without needing to parent every map in an area, with all the management logic that comes with?

this comes down to: _are there places that mutate an area field which has significance for more than one map in the area?_
the ones that could apply are:
- danger level
- atlas/tileset
- map type
- turn cost
- refresh type/generated every time
- designated spawns
- indoors

** api
#+BEGIN_SRC lua
  data:add {
     _type = "base.area",
     _id = "vernis",

     map = "base.vernis"
  }
#+END_SRC

#+BEGIN_SRC lua
  local primary = Area.get_primary_map()
  Map.travel_to(primary)

  local success, map = Map.generate("elona_sys.elona122", { name = "sqRogue" })
  Area.add_submap(map, 24, 45)

  -- groups this map into a new area and sets primary_map on it.
  Area.create_from_map(map)

  local function get_dungeon_level()
    local lv = 0
    for _, map in Map.current():get_area():iter_maps() do
      -- read the map from disk/hit the cache but do not deserialize any
      -- fields containing entities
      local data = Map.load_map_data(map)
      lv = math.max(lv, data.dungeon_level)
    end
    return lv
  end
#+END_SRC

** initialization
- in the very first economy initialization part, setup quest/politics variables.
  + if the map is not the scenario starting one, initialize it.
  + there is some dead code for the unimplemented economy/building/politics feature.
- when initializing the world map for whatever reason, look at all dungeons (presumably on the map itself, though vanilla assumes globally), and for each that has been conquered, create a new nefia somewhere.
- when preparing the world map, find an open spot to place each map area that's connected to the world map (never fails). if the map is a town or guild, add light to its tile.
- when doing world map earthquake:
  + if force is set, wipe all nefias. conquered == -1 means the map is conquered.
  + otherwise, randomly remove nefias if less than 25 nefias have been conquered, or 1 in 150 times.
* TODO continuous action (base)
* TODO schematize prototypes (base)
* TODO add fields to prototypes (elona_sys)
* TODO hook prototype into object system (base)
* TODO equipment properties on equip (base)
* TODO enchantments (elona_sys)
* TODO support all elona characters (elona)
* TODO strip all mods and run base with fallbacks (base)
determine which values should be set as defaults
* TODO NPC dialog (elona_sys)
* TODO dungeon generation (elona_sys)
* TODO applied effects (base/IObject)
* TODO timed effects (base)
* TODO move menus to elona_sys
* TODO display timed effect as status effect (base?)
* TODO damage handler/projector
* TODO additional AI actions (elona_sys)
* TODO data schema
* TODO pcc support
* TODO make Log support log tags
* TODO final graphical polish
spotlight, animated tiles, tall/large tiles

* TODO decide on the name
Elona_next
Elona_macs
Elona_evo
Elona_evol
